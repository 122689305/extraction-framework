package org.dbpedia.extraction.config.provenance

import java.net.URI
import java.util.MissingFormatArgumentException

import org.dbpedia.extraction.ontology.{DBpediaNamespace, RdfNamespace}
import org.dbpedia.extraction.util.{Language, WikiUtil}
import org.dbpedia.extraction.wikiparser.WikiParserException

import scala.util.{Failure, Success, Try}

/**
 * The quads generated by the DBpedia framework are organized in a number of datasets.
 */
class Dataset(
   naturalName: String,         //The title of the dataset
   descr: String = null,        //The description used for documentation
   lang: Language = null,       //The language (when dealing with a language specific version of the dataset)
   versionEntry: String = null, //The DBpedia version of the Dataset (e.g. 2016-04). If supplied this dataset is specific to (language and) DBpedia version.
   fileName: String = null,     //The name of this Dataset used in file names and uris (if null this will generated form the naturalName)
   orig: Dataset = null,        //The origin or parent dataset. for example: the parent of a Dataset with language and versionEntry, say long-abstracts for English/2016-04, is the corresponding general dataset without these attributes: DBpediaDatasets.LongAbstracts.
   var sources: Seq[Dataset] = Seq.empty[Dataset], //The Datasets out of which this dataset was extracted/generated...
   result: String = null,       //Uri of the Extractor/script which produced this dataset (see class DBpediaAnnotations)
   input: Seq[String] = Seq.empty[String],    //Uris of the Extractors/scripts which use this dataset as in input (see class DBpediaAnnotations)
   depr: String = null
   )
{
  val description = Option(descr)
  val language = Option(lang)
  var origin = Option(orig)

  val inputFor: Seq[Try[URI]] = input.map(x => Try{new URI(x)})

  val resultOf: Try[URI] = Option(result) match{
    case Some(u) => Try{new URI(u)}
    case None => Failure(new IllegalArgumentException("No target class for inputFor provided."))
  }

  val name = WikiUtil.wikiDecode(naturalName.trim)
  if (name.isEmpty) throw new WikiParserException("dataset name must not be empty")

  /** Wiki-encoded dataset name */
  val encoded = WikiUtil.wikiEncode((if(Option(fileName).nonEmpty && fileName.trim.nonEmpty) fileName.trim else name).replace("-", "_")).toLowerCase

  val canonicalUri = RdfNamespace.fullUri(DBpediaNamespace.DATASET, encoded)

  val version = testVersionString(versionEntry)

  val deprecatedSince = testVersionString(depr)

  private def testVersionString(str: String): Try[String] =Try {
    Option(depr) match {
      case Some(v) => "2\\d{3}-\\d{2}".r.findFirstMatchIn(v.trim) match {
        case Some(y) => if (y.end == 7) v.trim else throw new IllegalArgumentException("Provided version string did not match 2\\d{3}-\\d{2}")
        case None => throw new IllegalArgumentException("Provided version string did not match 2\\d{3}-\\d{2}")
      }
      case None => throw new IllegalArgumentException("No version string was provided.")
    }
  }

  def languageUri = this.language match{
    case Some(lang) => canonicalUri + "?lang=" + lang.wikiCode
    case None => canonicalUri
  }

  def versionUri = this.language match {
    case Some(l) => version match
    {
      case Success(v) => this.languageUri + "&dbpv=" + v
      case Failure(e) => this.languageUri
    }
    case None => canonicalUri
  }

  def isCanonical = language match {
    case Some(lang) => false
    case None => true
  }

  def getDistributionUri(distType: String, extension: String) ={
    val lang = this.language match{
      case Some(l) => l
      case None => throw new MissingFormatArgumentException("Dataset is language unspecific and can therefore not provide distribution URIs. Please specify a language first!.")
    }
    this.versionUri + "&" + distType  + "=" + this.encoded +"_" + lang.wikiCode + extension
  }

  override def toString = name

  override def hashCode = encoded.hashCode
  
  override def equals(other : Any) = other match {
    case that: Dataset => (this.encoded == that.encoded)
    case _ => false
  }
}
